<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <!-- Favicon -->
    <link rel="icon" href="https://solustoc.com/wp-content/uploads/2025/03/cropped-logo-solu-stoc-scaled-1.jpg?v=2" type="image/jpeg" />
    <link rel="shortcut icon" href="https://solustoc.com/wp-content/uploads/2025/03/cropped-logo-solu-stoc-scaled-1.jpg?v=2" type="image/jpeg" />
    <link rel="apple-touch-icon" href="https://solustoc.com/wp-content/uploads/2025/03/cropped-logo-solu-stoc-scaled-1.jpg?v=2" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Solustoc - Négoce & Déstockage B2B Vin</title>
    <script type="module" crossorigin src="./index-CiN389WB.js"></script>
    <link rel="stylesheet" crossorigin href="./index-BvEbwHs3.css">
  </head>
  <body>
    <div id="root"></div>

    <!-- Réduction "safe" du bandeau à ~35vh (sans masquer le contenu suivant) -->
    <script>
      (function () {
        function shrinkHero() {
          const root = document.getElementById('root');
          if (!root) return;

          const nodes = Array.from(
            root.querySelectorAll('section, header, main section, div')
          ).filter(el => el.getBoundingClientRect().top < window.innerHeight * 0.4);

          // 1) Priorité : un bloc qui contient "Solution Discr"
          let hero = nodes.find(el =>
            (el.textContent || '').toLowerCase().includes('solution discr')
          );

          // 2) Sinon, un bloc avec classes plein écran (Tailwind-like)
          if (!hero) hero = nodes.find(el => /\b(min-)?h-(screen|svh)\b/.test(el.className || ''));

          // 3) Sinon, le plus grand parmi les premiers candidats
          if (!hero) {
            hero = nodes.sort(
              (a, b) => b.getBoundingClientRect().height - a.getBoundingClientRect().height
            )[0];
          }
          if (!hero) return;

          // Retire les classes plein écran si présentes
          hero.className = (hero.className || '')
            .replace(/\bmin-h-screen\b/g, '')
            .replace(/\bh-screen\b/g, '')
            .replace(/\bmin-h-svh\b/g, '')
            .replace(/\bh-svh\b/g, '')
            .trim();

          // Réglages "safe"
          hero.style.minHeight = '35vh';
          hero.style.height = 'auto';
          hero.style.paddingTop = '3rem';
          hero.style.paddingBottom = '3rem';
        }

        window.addEventListener('load', () => {
          shrinkHero();
          setTimeout(shrinkHero, 200);
        });

        const mo = new MutationObserver(() => {
          clearTimeout(window.__shr_to);
          window.__shr_to = setTimeout(shrinkHero, 60);
        });
        mo.observe(document.documentElement, { childList: true, subtree: true });
      })();
    </script>

    <!-- Uniformise "Découvrir nos services" sur "Demander un échange" -->
    <script>
      (function () {
        const norm = s =>
          (s || '')
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .toLowerCase()
            .replace(/\s+/g, ' ')
            .trim();

        function equalizeButtons() {
          const root = document.getElementById('root');
          if (!root) return;

          const candidates = root.querySelectorAll('button, a, [role="button"]');

          const findByText = (needle) => {
            const n = norm(needle);
            for (const el of candidates) {
              const t = norm(el.textContent);
              if (t.includes(n)) return el;
            }
            return null;
          };

          // Source (style à copier)
          const src =
            findByText('demander un echange') || findByText('demander un échange');

          // Cible (à recolorer)
          const dst =
            findByText('decouvrir nos services') || findByText('découvrir nos services');

          if (src && dst) {
            const cs = getComputedStyle(src);
            const props = [
              'background','backgroundColor','backgroundImage','backgroundSize','backgroundPosition','backgroundRepeat',
              'border','borderColor','borderStyle','borderWidth','borderRadius','boxShadow',
              'color','textTransform','letterSpacing','fontWeight',
              'padding','paddingTop','paddingBottom','paddingLeft','paddingRight',
              'transition','filter'
            ];
            props.forEach(p => { try { dst.style[p] = cs[p]; } catch(e){} });
            dst.style.cursor = 'pointer';
          }
        }

        window.addEventListener('load', () => {
          equalizeButtons();
          setTimeout(equalizeButtons, 200);
        });

        const root = document.getElementById('root');
        if (root) {
          let t;
          const mo = new MutationObserver(() => {
            clearTimeout(t);
            t = setTimeout(equalizeButtons, 60);
          });
          mo.observe(root, { childList: true, subtree: true });
        }
      })();
    </script>

    <!-- Nettoyage du footer : SUPPRIME UNIQUEMENT les doublons SANS lien (ne touche JAMAIS aux <a>) -->
    <script>
      (function () {
        const LABELS = [
          'Revalorisation de lots',
          'Mise en relation B2B',
          'Conseil en négoce',
          'Solutions discrètes'
        ];

        // Normalisation robuste (accents, ponctuation, espaces)
        function norm(s) {
          return (s || '')
            .normalize('NFD').replace(/[\u0300-\u036f]/g,'') // accents
            .replace(/[•|·|·|\-|–|—|:|;|,|\.|\/|\(|\)|\[|\]]/g,' ') // ponctuation courante
            .toLowerCase()
            .replace(/\s+/g,' ')
            .trim();
        }

        function hasAnchorAncestor(node) {
          let p = node.parentNode;
          while (p) {
            if (p.nodeType === 1 && p.tagName === 'A') return true;
            p = p.parentNode;
          }
          return false;
        }

        function containsAnchor(el) {
          return !!el.querySelector('a');
        }

        function removeTextNode(node) {
          if (node && node.parentNode) node.parentNode.removeChild(node);
        }

        function cleanFooterOnce() {
          const root = document.getElementById('root');
          const footer = (root && root.querySelector('footer')) || document.querySelector('footer');
          if (!footer) return;

          // 1) Récupère les libellés EXACTS présents en liens (référence)
          const anchorLabels = new Set(
            Array.from(footer.querySelectorAll('a'))
              .map(a => norm(a.textContent))
              .filter(t => t) // non vide
          );

          // Si aucun lien service, on ne touche à rien
          if (anchorLabels.size === 0) return;

          // 2) Supprime les TEXT NODES qui doublonnent ces libellés et NE sont pas dans/avec un lien
          const walker = document.createTreeWalker(footer, NodeFilter.SHOW_TEXT, null);
          const toRemove = [];
          while (walker.nextNode()) {
            const tn = walker.currentNode;
            const txt = norm(tn.textContent);
            if (!txt) continue;
            if (hasAnchorAncestor(tn)) continue; // ne pas toucher aux textes à l'intérieur d'un lien
            if (anchorLabels.has(txt)) {
              toRemove.push(tn);
            }
          }
          toRemove.forEach(removeTextNode);

          // 3) Supprime les petites balises SANS lien qui ne contiennent que ces libellés
          const els = footer.querySelectorAll('*');
          els.forEach(el => {
            if (el.tagName === 'A') return;
            if (containsAnchor(el)) return;
            if (el.childElementCount > 0) return; // on ne cible que les "feuilles"
            const t = norm(el.textContent);
            if (!t) return;
            if (anchorLabels.has(t)) {
              el.remove();
            }
          });
        }

        function cleanFooter() {
          // double passe pour les rendus différés
          cleanFooterOnce();
          setTimeout(cleanFooterOnce, 200);
        }

        window.addEventListener('load', cleanFooter);

        // Réapplique uniquement si le footer change
        const observerTarget = document.documentElement;
        new MutationObserver((muts) => {
          for (const m of muts) {
            if (m.target && (m.target.closest && m.target.closest('footer'))) {
              cleanFooter();
              break;
            }
          }
        }).observe(observerTarget, { childList: true, subtree: true });
      })();
    </script>
    <!-- Linkifier les 4 services du footer (convertit le texte en <a href="...">) -->
<!-- Linkifier correctement le bloc de services du footer -->
<script>
(function(){
  const SERVICES = [
    { label: 'Revalorisation de lots', href: '/revalorisation.html' },
    { label: 'Mise en relation B2B',   href: '/mise-en-relation-b2b.html' },
    { label: 'Conseil en négoce',      href: '/conseil-negoce.html' },
    { label: 'Solutions discrètes',    href: '/solutions-discretes.html' },
  ];
  const norm = s => (s||'')
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')   // accents
    .toLowerCase().replace(/\s+/g,' ').trim();

  function buildLinksFragment() {
    const frag = document.createDocumentFragment();
    SERVICES.forEach((svc, i) => {
      const a = document.createElement('a');
      a.href = svc.href;
      a.textContent = svc.label;
      a.style.textDecoration = 'underline';
      frag.appendChild(a);
      if (i < SERVICES.length - 1) frag.appendChild(document.createTextNode(' • '));
    });
    return frag;
  }

  function linkifyServicesBlock() {
    const root = document.getElementById('root');
    const footer = (root && root.querySelector('footer')) || document.querySelector('footer');
    if (!footer) return;

    // 1) On cherche un élément (pas <a>) qui contient AU MOINS 2 intitulés et aucun lien à l'intérieur
    const candidates = Array.from(footer.querySelectorAll('*:not(a)')).filter(el => {
      if (el.querySelector('a')) return false; // on ne touche pas si des liens sont déjà dedans
      const txt = norm(el.textContent);
      if (!txt) return false;
      let hits = 0;
      for (const s of SERVICES) if (txt.includes(norm(s.label))) hits++;
      return hits >= 2; // bloc combiné
    });

    if (candidates.length) {
      // On prend celui avec le plus de correspondances
      candidates.sort((a, b) => {
        const ha = SERVICES.reduce((n,s)=>n + (norm(a.textContent).includes(norm(s.label))?1:0), 0);
        const hb = SERVICES.reduce((n,s)=>n + (norm(b.textContent).includes(norm(s.label))?1:0), 0);
        return hb - ha;
      });
      const target = candidates[0];
      // Remplace intégralement son contenu par les 4 liens propres
      target.innerHTML = '';
      target.appendChild(buildLinksFragment());
      return;
    }

    // 2) Fallback : si chaque libellé est dans un petit élément séparé sans lien, on remplace feuille par <a>
    const leaves = footer.querySelectorAll('*:not(a)');
    leaves.forEach(el => {
      if (el.childElementCount > 0) return;
      if (el.querySelector && el.querySelector('a')) return;
      const raw = (el.textContent || '').trim();
      if (!raw) return;
      const svc = SERVICES.find(s => norm(raw) === norm(s.label));
      if (svc) {
        const a = document.createElement('a');
        a.href = svc.href;
        a.textContent = raw;
        a.style.textDecoration = 'underline';
        el.replaceWith(a);
      }
    });
  }

  // Lance et relance après rendu
  window.addEventListener('load', () => { linkifyServicesBlock(); setTimeout(linkifyServicesBlock, 150); });
  new MutationObserver(() => linkifyServicesBlock())
    .observe(document.documentElement, { childList: true, subtree: true });
})();
</script>

 

  </body>
</html>
